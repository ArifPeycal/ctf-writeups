# ezcoppersmith
## Description
> Easy coppersmith?

## Challenge Overview
We get a Python script that generates an RSA encryption scheme using specific parameters. It prints the public modulus (n) and the ciphertext (ct) after encrypting the flag.
```py
import os
from Crypto.Util.number import bytes_to_long, getPrime
from random import getrandbits
from sympy import nextprime
flag = os.urandom(70)+b"CSCTF{fake_flag}"+os.urandom(70)
flag = bytes_to_long(flag)
e = 0x10001
p = getPrime(1024)
q = nextprime(p+getrandbits(512))
n = p*q
ct = pow(flag,e,n)

print(f"{n = }")
print(f"{ct = }")

"""
n = 18644771606497209714095542646224677588981048892455227811334258151262006531336794833359381822210403450387218291341636672728427659163488688386134401896278003165147721355406911673373424263190196921309228396204979060454870860816745503197616145647490864293442635906688253552867657780735555566444060335096583505652012496707636862307239874297179019995999007369981828074059533709513179171859521707075639202212109180625048226522596633441264313917276824985895380863669296036099693167611788521865367087640318827068580965890143181999375133385843774794990578010917043490614806222432751894223475655601237073207615381387441958773717
ct = 814602066169451977605898206043894866509050772237095352345693280423339237890197181768582210420699418615050495985283410604981870683596059562903004295804358339676736292824636301426917335460641348021235478618173522948941541432284037580201234570619769478956374067742134884689871240482950578532380612988605675957629342412670503628580284821612200740753343166428553552463950037371300722459849775674636165297063660872395712545246380895584677099483139705934844856029861773030472761407204967590283582345034506802227442338228782131928742229041926847011673393223237610854842559028007551817527116991453411203276872464110797091619
"""
```
In the challenge title, it gives hint that we need to use `Coppersmith's Attack` 
> Coppersmith's attack is a cryptographic attack on RSA that can recover small private keys or plaintexts under certain conditions. Specifically, the attack is effective if the plaintext (in this case, the flag) is small relative to the modulus n.


In this script:

- The modulus n is generated from p and q where q is very close to p (i.e., q≈p). This makes the factorization of n potentially vulnerable, especially if the gap between p and q is small enough. 
## Solution
By factorizing the modulus n, the private key d is derived, allowing for the decryption of the ciphertext ct to retrieve the original plaintext flag. This approach is theoretically possible due to the vulnerability of RSA when the modulus n is factorizable, which would normally be computationally infeasible if n were generated securely with sufficiently large primes.
```py
from Crypto.Util.number import inverse, long_to_bytes
import sympy

# Given values
n = 18644771606497209714095542646224677588981048892455227811334258151262006531336794833359381822210403450387218291341636672728427659163488688386134401896278003165147721355406911673373424263190196921309228396204979060454870860816745503197616145647490864293442635906688253552867657780735555566444060335096583505652012496707636862307239874297179019995999007369981828074059533709513179171859521707075639202212109180625048226522596633441264313917276824985895380863669296036099693167611788521865367087640318827068580965890143181999375133385843774794990578010917043490614806222432751894223475655601237073207615381387441958773717
ct = 814602066169451977605898206043894866509050772237095352345693280423339237890197181768582210420699418615050495985283410604981870683596059562903004295804358339676736292824636301426917335460641348021235478618173522948941541432284037580201234570619769478956374067742134884689871240482950578532380612988605675957629342412670503628580284821612200740753343166428553552463950037371300722459849775674636165297063660872395712545246380895584677099483139705934844856029861773030472761407204967590283582345034506802227442338228782131928742229041926847011673393223237610854842559028007551817527116991453411203276872464110797091619
e = 0x10001

# Factorize n
p, q = sympy.factorint(n).keys()

# Compute φ(n)
phi_n = (p - 1) * (q - 1)

# Compute modular inverse of e
d = inverse(e, phi_n)

# Decrypt the ciphertext
m = pow(ct, d, n)
flag = long_to_bytes(m)

print(flag)
```
## Flag
```
CTF{c0pp3rsm1th_1s_a_m4th_g0d_n0_d0ub7}
```
